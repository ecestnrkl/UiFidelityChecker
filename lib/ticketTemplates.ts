import {
  ComparisonResult,
  Mismatch,
  TicketConfig,
  TicketData,
  TicketMetadata,
  TicketFinding,
  StructuredTicket,
  Severity,
} from "./types";

/**
 * Map priority to severity based on config
 */
function mapPriorityToSeverity(
  priority: "high" | "medium" | "low",
  config: TicketConfig
): Severity {
  if (config.severityMapping) {
    return config.severityMapping[priority];
  }
  // Default mapping
  const defaultMapping: Record<"high" | "medium" | "low", Severity> = {
    high: "critical",
    medium: "major",
    low: "minor",
  };
  return defaultMapping[priority];
}

/**
 * Build ticket metadata from result and config
 */
function buildTicketMetadata(
  result: ComparisonResult,
  config: TicketConfig
): TicketMetadata {
  return {
    screenName: config.screenName || result.metadata.screenName,
    platform: config.platform || result.metadata.platform,
    viewport: "Desktop", // Could be extended to include actual viewport
    timestamp: result.metadata.comparedAt,
    similarityMetric: result.similarity,
    environment: config.environment,
    projectName: config.projectName,
    assignee: config.assignee,
    labels: config.labels,
  };
}

/**
 * Build ticket findings from mismatches
 */
function buildTicketFindings(
  mismatches: Mismatch[],
  config: TicketConfig
): TicketFinding[] {
  return mismatches.map((m) => ({
    id: m.id,
    title: m.title,
    category: m.category,
    priority: m.priority,
    severity: mapPriorityToSeverity(m.priority, config),
    explanation: m.explanation,
    suggestedFix: m.suggestedFix,
    bbox: m.bbox,
  }));
}

/**
 * Build structured ticket object
 */
function buildStructuredTicket(
  result: ComparisonResult,
  selectedMismatches: string[],
  config: TicketConfig
): StructuredTicket {
  const mismatches = result.mismatches.filter((m) =>
    selectedMismatches.includes(m.id)
  );

  return {
    metadata: buildTicketMetadata(result, config),
    findings: buildTicketFindings(mismatches, config),
    diffImageReference: "diff-image.png",
  };
}

/**
 * Generate Generic Markdown template
 */
function generateGenericMarkdown(ticket: StructuredTicket): string {
  const { metadata, findings } = ticket;

  const title = `[UI Fidelity] ${metadata.screenName || "Screen"} ${
    metadata.platform ? `(${metadata.platform})` : ""
  }`;

  const contextLines = [
    `**Screen**: ${metadata.screenName || "N/A"}`,
    `**Platform**: ${metadata.platform || "N/A"}`,
    `**Viewport**: ${metadata.viewport || "N/A"}`,
    `**Environment**: ${metadata.environment || "N/A"}`,
    `**Compared**: ${new Date(metadata.timestamp).toLocaleString()}`,
  ];

  const summaryLine = `**Similarity Score**: ${metadata.similarityMetric}% (${
    100 - metadata.similarityMetric
  }% mismatch)`;

  const findingsList = findings
    .map(
      (f, idx) => `
### ${idx + 1}. ${f.title}

- **Category**: ${f.category}
- **Priority**: ${f.priority} (Severity: ${f.severity})
- **Location**: x:${f.bbox.x}, y:${f.bbox.y}, w:${f.bbox.width}, h:${f.bbox.height}

**Issue**: ${f.explanation}

**Suggested Fix**: ${f.suggestedFix}

---
`
    )
    .join("\n");

  const evidenceSection = `## Evidence

- Diff image: \`${ticket.diffImageReference}\`
- Bounding box coordinates identify exact pixel locations of mismatches`;

  return `# ${title}

## Context

${contextLines.join("\n")}

## Summary

${summaryLine}

## Findings (${findings.length})

${findingsList}

${evidenceSection}

---

*Generated by UI Fidelity Checker*
`;
}

/**
 * Generate GitHub Issue Markdown template
 */
function generateGitHubMarkdown(ticket: StructuredTicket): string {
  const { metadata, findings } = ticket;

  const title = `[UI Fidelity] ${metadata.screenName || "Screen"} - ${
    findings.length
  } visual mismatch${findings.length !== 1 ? "es" : ""}`;

  const labelsLine = metadata.labels
    ? `**Labels**: ${metadata.labels.join(", ")}`
    : "";
  const assigneeLine = metadata.assignee
    ? `**Assignee**: @${metadata.assignee}`
    : "";

  const expectedVsActual = `### Expected vs Actual

**Expected**: Design mockup matches implementation pixel-perfect
**Actual**: ${findings.length} visual differences detected with ${metadata.similarityMetric}% similarity`;

  const stepsToReproduce = `### Steps to Reproduce

1. Navigate to **${metadata.screenName || "the screen"}** on **${
    metadata.platform || "platform"
  }**
2. Capture screenshot using viewport: **${metadata.viewport || "Desktop"}**
3. Compare against design mockup
4. Observe ${findings.length} visual discrepancies`;

  const acceptanceCriteria = `### Acceptance Criteria

- [ ] All ${findings.length} visual mismatches are resolved
- [ ] Similarity score reaches ≥99%
- [ ] Re-run UI Fidelity Checker to verify fixes`;

  const findingsTable = `### Findings

| # | Issue | Category | Priority | Location | Fix |
|---|-------|----------|----------|----------|-----|
${findings
  .map(
    (f, idx) =>
      `| ${idx + 1} | ${f.title} | ${f.category} | ${f.priority} | x:${f.bbox.x}, y:${f.bbox.y} | ${f.suggestedFix} |`
  )
  .join("\n")}`;

  const evidence = `### Evidence

- **Diff image**: See attachment \`${ticket.diffImageReference}\`
- **Comparison date**: ${new Date(metadata.timestamp).toLocaleDateString()}
- **Environment**: ${metadata.environment || "N/A"}`;

  return `${labelsLine}
${assigneeLine}

${expectedVsActual}

${stepsToReproduce}

${acceptanceCriteria}

${findingsTable}

${evidence}

---

*Generated by UI Fidelity Checker*
`;
}

/**
 * Generate Jira-style text template
 */
function generateJiraText(ticket: StructuredTicket): string {
  const { metadata, findings } = ticket;

  const summary = `UI Fidelity: ${metadata.screenName || "Screen"} - ${
    findings.length
  } visual issues`;

  const description = `*Expected vs Actual*

Expected: Design mockup matches implementation pixel-perfect
Actual: ${findings.length} visual differences detected with ${
    metadata.similarityMetric
  }% similarity

*Reproduction Steps*

1. Navigate to ${metadata.screenName || "the screen"} on ${
    metadata.platform || "platform"
  }
2. Capture screenshot using viewport: ${metadata.viewport || "Desktop"}
3. Compare against design mockup
4. Observe ${findings.length} visual discrepancies

*Acceptance Criteria*

- All ${findings.length} visual mismatches are resolved
- Similarity score reaches ≥99%
- Re-run UI Fidelity Checker to verify fixes

*Findings*

${findings
  .map(
    (f, idx) => `${idx + 1}. [${f.priority.toUpperCase()}] ${f.title}
   Category: ${f.category}
   Location: x:${f.bbox.x}, y:${f.bbox.y} (${f.bbox.width}×${f.bbox.height}px)
   Issue: ${f.explanation}
   Fix: ${f.suggestedFix}
`
  )
  .join("\n")}

*Evidence*

- Diff image: ${ticket.diffImageReference}
- Comparison date: ${new Date(metadata.timestamp).toLocaleDateString()}
- Environment: ${metadata.environment || "N/A"}
${metadata.labels ? `- Labels: ${metadata.labels.join(", ")}` : ""}
${metadata.assignee ? `- Assignee: ${metadata.assignee}` : ""}
`;

  return `Summary: ${summary}

Description:
${description}`;
}

/**
 * Generate JSON export with schema
 */
function generateJSONExport(ticket: StructuredTicket): string {
  const jsonSchema = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "UI Fidelity Ticket",
    type: "object",
    properties: {
      metadata: {
        type: "object",
        properties: {
          screenName: { type: "string" },
          platform: { type: "string" },
          viewport: { type: "string" },
          timestamp: { type: "string", format: "date-time" },
          similarityMetric: { type: "number", minimum: 0, maximum: 100 },
          environment: { type: "string" },
          projectName: { type: "string" },
          assignee: { type: "string" },
          labels: { type: "array", items: { type: "string" } },
        },
        required: ["timestamp", "similarityMetric"],
      },
      findings: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            title: { type: "string" },
            category: { type: "string" },
            priority: { type: "string" },
            severity: { type: "string" },
            explanation: { type: "string" },
            suggestedFix: { type: "string" },
            bbox: {
              type: "object",
              properties: {
                x: { type: "number" },
                y: { type: "number" },
                width: { type: "number" },
                height: { type: "number" },
              },
              required: ["x", "y", "width", "height"],
            },
          },
          required: [
            "id",
            "title",
            "category",
            "priority",
            "severity",
            "explanation",
            "suggestedFix",
            "bbox",
          ],
        },
      },
      diffImageReference: { type: "string" },
    },
    required: ["metadata", "findings"],
  };

  const output = {
    schema: jsonSchema,
    ticket,
  };

  return JSON.stringify(output, null, 2);
}

/**
 * Main ticket generation function
 * Handles single bundled ticket or one-per-mismatch
 */
export function generateTickets(
  result: ComparisonResult,
  selectedMismatches: string[],
  config: TicketConfig
): TicketData[] {
  // If no mismatches selected, default to top 3 by priority
  let targetMismatches = selectedMismatches;
  if (targetMismatches.length === 0) {
    const priorityOrder = { high: 0, medium: 1, low: 2 };
    const sortedMismatches = [...result.mismatches].sort(
      (a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]
    );
    targetMismatches = sortedMismatches.slice(0, 3).map((m) => m.id);
  }

  if (config.granularity === "single-bundled") {
    // Generate single bundled ticket
    const ticket = buildStructuredTicket(result, targetMismatches, config);
    const content = generateTicketContent(ticket, config.format);
    const { filename, mimeType } = getTicketFileInfo(config.format, "bundled");

    return [{ title: getTicketTitle(ticket), content, filename, mimeType }];
  } else {
    // Generate one ticket per mismatch
    return targetMismatches.map((mismatchId) => {
      const ticket = buildStructuredTicket(result, [mismatchId], config);
      const content = generateTicketContent(ticket, config.format);
      const { filename, mimeType } = getTicketFileInfo(
        config.format,
        ticket.findings[0]?.title || "mismatch"
      );

      return { title: getTicketTitle(ticket), content, filename, mimeType };
    });
  }
}

/**
 * Generate ticket content based on format
 */
function generateTicketContent(
  ticket: StructuredTicket,
  format: TicketConfig["format"]
): string {
  switch (format) {
    case "generic-markdown":
      return generateGenericMarkdown(ticket);
    case "github-markdown":
      return generateGitHubMarkdown(ticket);
    case "jira-text":
      return generateJiraText(ticket);
    case "json":
      return generateJSONExport(ticket);
    default:
      return generateGenericMarkdown(ticket);
  }
}

/**
 * Get ticket title
 */
function getTicketTitle(ticket: StructuredTicket): string {
  const { metadata, findings } = ticket;
  return `[UI Fidelity] ${metadata.screenName || "Screen"} - ${
    findings.length
  } issue${findings.length !== 1 ? "s" : ""}`;
}

/**
 * Get file info for download
 */
function getTicketFileInfo(
  format: TicketConfig["format"],
  baseName: string
): { filename: string; mimeType: string } {
  const sanitizedName = baseName
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-|-$/g, "");

  switch (format) {
    case "generic-markdown":
    case "github-markdown":
      return {
        filename: `ui-fidelity-${sanitizedName}.md`,
        mimeType: "text/markdown",
      };
    case "jira-text":
      return {
        filename: `ui-fidelity-${sanitizedName}.txt`,
        mimeType: "text/plain",
      };
    case "json":
      return {
        filename: `ui-fidelity-${sanitizedName}.json`,
        mimeType: "application/json",
      };
    default:
      return {
        filename: `ui-fidelity-${sanitizedName}.md`,
        mimeType: "text/markdown",
      };
  }
}

/**
 * Generate GitHub issue URL with prefilled title and body
 */
export function generateGitHubIssueURL(
  repoOwner: string,
  repoName: string,
  title: string,
  body: string,
  labels?: string[]
): string {
  const baseURL = `https://github.com/${repoOwner}/${repoName}/issues/new`;
  const params = new URLSearchParams();

  params.append("title", title);
  params.append("body", body);

  if (labels && labels.length > 0) {
    params.append("labels", labels.join(","));
  }

  return `${baseURL}?${params.toString()}`;
}
